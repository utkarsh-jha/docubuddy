import subprocess
import os


def compare_commits(previous_head, current_head, directory_filter=None):
    """
    Compare two commits and return a list of differences as structured JSON.
    """
    try:
        diff_output = subprocess.check_output(
            ["git", "diff", previous_head, current_head], universal_newlines=True
        )
        diff = []
        current_file = None

        for line in diff_output.splitlines():
            if line.startswith("diff --git"):
                file_name = line.split(" ")[-1].replace("b/", "")
                # Check if file is in any of the filtered directories
                if any(
                        not directory_filter or
                        len(directory_filter) == 0 or
                        file_name.startswith(folder + "/")
                        or file_name.startswith(folder + "\\")
                        for folder in directory_filter
                ):
                    current_file = {"file": file_name, "changes": []}
                    diff.append(current_file)
                else:
                    current_file = None  # Skip this file
            elif line.startswith("@@"):
                if current_file:  # Only process if we're tracking this file
                    parts = line.split(" ")
                    old_range = parts[1]
                    new_range = parts[2]
                    current_file["changes"].append(
                        {"old_range": old_range, "new_range": new_range, "content": []}
                    )
            elif line.strip() == "\\ No newline at end of file":
                if (
                        current_file and current_file["changes"]
                ):  # Only process if we're tracking this file
                    current_file["changes"][-1]["note"] = "No newline at end of file"
            else:
                if current_file and current_file["changes"]:
                    current_file["changes"][-1]["content"].append(line)

        from pprint import pprint

        pprint("Diff between commits:")
        pprint(diff)
        return diff

    except subprocess.CalledProcessError as e:
        print(f"Error getting diff: {e}")
        return []


def apply_documentation_patches(doc_suggestions):
    """
    Apply the documentation patches generated by the LLM to the actual files.

    Args:
        doc_suggestions: Dictionary with file names as keys and patch content as values

    Returns:
        dict: Results of patch application for each file
    """
    application_results = {}

    for file_name, patch_content in doc_suggestions.items():
        if patch_content.startswith("Error:"):
            application_results[file_name] = "Skipped due to LLM error"
            continue

        # Skip if no meaningful patch content
        if not patch_content.strip() or "no documentation changes are needed" in patch_content.lower():
            application_results[file_name] = "No documentation changes needed"
            continue

        print(f"Applying documentation patch for: {file_name}")

        try:
            # Write patch to a temporary file
            patch_file = f"{file_name}.patch"
            with open(patch_file, 'w', encoding='utf-8') as f:
                f.write(patch_content)
                print(f"Patch file created: {patch_file}")

            patch_file = os.path.abspath(patch_file)
            # Try to apply the patch using git apply
            try:
                print(f"{['git', 'apply', '--check', patch_file],}")
                result = subprocess.run(
                    ['git', 'apply', '--check', patch_file],
                    capture_output=True,
                    text=True,
                    cwd=os.path.dirname(os.path.abspath(file_name)) if os.path.dirname(file_name) else '.',
                )
                print(f"Checking patch validity for {file_name}...")
                print(result.stdout)
                print(patch_file)
                print(result.stderr)
                if result.returncode == 0:
                    # Patch is valid, apply it
                    apply_result = subprocess.run(
                        ['git', 'apply', patch_file],
                        capture_output=True,
                        text=True,
                        cwd=os.path.dirname(os.path.abspath(file_name)) if os.path.dirname(file_name) else '.',
                    )

                    if apply_result.returncode == 0:
                        application_results[file_name] = "Successfully applied documentation patch"
                        print(f"✓ Successfully applied patch for {file_name}")
                    else:
                        application_results[file_name] = f"Failed to apply patch: {apply_result.stderr}"
                        print(f"✗ Failed to apply patch for {file_name}: {apply_result.stderr}")
                else:
                    application_results[file_name] = f"Invalid patch format: {result.stderr}"
                    print(f"✗ Invalid patch for {file_name}: {result.stderr}")

            except subprocess.CalledProcessError as e:
                application_results[file_name] = f"Git apply error: {e}"
                print(f"✗ Git apply error for {file_name}: {e}")

            # Clean up temporary patch file
            try:
                os.remove(patch_file)
            except OSError:
                pass  # Ignore cleanup errors

        except Exception as e:
            application_results[file_name] = f"Error creating patch file: {e}"
            # print stacktrace
            import traceback
            traceback.print_exc()
            print(f"✗ Error processing patch for {file_name}: {e}")

    return application_results


def create_backup_before_patches(file_list):
    """
    Create backup copies of files before applying patches.

    Args:
        file_list: List of file names to backup

    Returns:
        dict: Mapping of original files to backup file names
    """
    backup_mapping = {}
    timestamp = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).strip().decode('utf-8')

    for file_name in file_list:
        if os.path.exists(file_name):
            backup_name = f"{file_name}.backup-{timestamp}"
            try:
                import shutil
                shutil.copy2(file_name, backup_name)
                backup_mapping[file_name] = backup_name
                print(f"Created backup: {backup_name}")
            except Exception as e:
                print(f"Warning: Could not create backup for {file_name}: {e}")

    return backup_mapping